import { Maybe } from "@quenk/noni/lib/data/maybe";

import { Content, WMLElement } from "..";
import { Entry, ViewFrame } from "./frame";

/**
 * Renderer is a function that builds up a ViewFrame on behalf of the view.
 */
export type Renderer = (frame: ViewFrame) => ViewFrame;

/**
 * View instances are compiled from wml template files.
 *
 * They provide an api for rendering user interfaces and
 * querying individual objects(WMLElement) it is made of.
 */
export interface View {
  /**
   * render the View.
   *
   * If a ViewFrame is provided, it will be used instead of creating a new one
   * internally. In this case the View itself will not be mutated.
   */
  render(frame?:ViewFrame): Content;

  /**
   * invalidate this View causing the DOM to be re-rendered.
   *
   * Re-rendering is done by finding the parentNode of the root
   * of the View's Content and replacing it with a new version.
   * If the view has not yet been added to the DOM, this will fail.
   */
  invalidate(): void;

  /**
   * findById retrives a WMLElement that has been assigned a `wml:id`
   * attribute matching id.
   */
  findById<E extends WMLElement>(id: string): Maybe<E>;

  /**
   * findGroupById retrives an array of WMLElements that have a `wml:group`
   * attribute matching name.
   */
  findGroupById<E extends WMLElement>(name: string): E[];
}

/**
 * BaseView used by generated view code.
 *
 * Previously logic was generated by the compiler but now the compiler
 * generates classes that extend this one.
 */
export class BaseView implements View {
  constructor(
    public context: object,
    public renderer: Renderer,
    public frame = new ViewFrame()
  ) {}

  findById<E extends WMLElement>(id: string): Maybe<E> {
    return this.frame
      .findById(id)
      .map((ent: Entry) => <E>(ent.widget ?? ent.node));
  }

  findGroupById<E extends WMLElement>(name: string): E[] {
    return <E[]>this.frame.findGroupBy(name).map(entry => entry.widget ?? entry.node);
  }

  invalidate(): void {
    //TODO: Support optional id/group
    let { frame } = this;

    if (frame.tree == null || frame.tree.parentNode == null)
      throw new Error(
        "invalidate(): cannot invalidate this view, it has no parent node!",
      );

    let parent = frame.tree.parentNode;

    let newTree = this.render();

    this.frame = this.renderer(new ViewFrame());

    parent.replaceChild(newTree, frame.tree);
  }

  render(frame?: ViewFrame): Content {
    //TODO onDOMConnected/onDOMDisconnected
    if(frame) return <Content>this.renderer(frame).tree;

    this.frame = this.renderer(new ViewFrame());
    return <Content>this.frame.tree;
  }
}
