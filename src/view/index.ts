import { Maybe } from "@quenk/noni/lib/data/maybe";

import { Content, WMLElement, WMLId } from "..";
import { Entry, ViewFrame } from "./frame";

/**
 * Renderer is a function that builds up a ViewFrame on behalf of the view.
 */
export type Renderer = (frame: ViewFrame) => ViewFrame;

/**
 * View instances are compiled from wml template files.
 *
 * They provide an api for rendering user interfaces and
 * querying individual objects(WMLElement) it is made of.
 */
export interface View {
  /**
   * render the View.
   *
   * If a ViewFrame is provided, it will be used instead of creating a new one
   * internally. In this case the View itself will not be mutated internally.
   */
  render(frame?: ViewFrame): Content;

  /**
   * invalidate this View causing the DOM to be re-rendered.
   *
   * Re-rendering is done by finding the parentNode of the root of the View's
   * content and replacing it with a new version. If an id  or a group prefixed
   * by '$' is passed, then only the corresponding content is invalidated.
   *
   * It is an error to invaldiate a View that has not yet been added to the DOM.
   */
  invalidate(target?: WMLId): void;

  /**
   * findById retrives a WMLElement that has been assigned a `wml:id`
   * attribute matching id.
   */
  findById<E extends WMLElement>(id: string): Maybe<E>;

  /**
   * findGroupById retrives an array of WMLElements that have a `wml:group`
   * attribute matching name.
   */
  findGroupById<E extends WMLElement>(name: string): E[];
}

/**
 * BaseView used by generated view code.
 *
 * Previously logic was generated by the compiler but now the compiler
 * generates classes that extend this one.
 */
export class BaseView implements View {
  constructor(
    public context: object,
    public renderer: Renderer,
    public frame = new ViewFrame(),
  ) {}

  findById<E extends WMLElement>(id: string): Maybe<E> {
    return this.frame
      .findById(id)
      .map((ent: Entry) => <E>(ent.widget ?? ent.node));
  }

  findGroupById<E extends WMLElement>(name: string): E[] {
    return <E[]>(
      this.frame.findByGroup(name).map((entry) => entry.widget ?? entry.node)
    );
  }

  invalidate(id?: WMLId): void {
    let { frame } = this;

    if (frame.tree == null || frame.tree.parentNode == null)
      return console.warn(
        "invalidate(): cannot invalidate this view, it has no parent node!",
      );

    if (id) {
      let next = this.renderer(new ViewFrame());
      if (id[0] === "$") frame.replaceByGroup(next, id.slice(1));
      else frame.replaceById(next, id);
    } else {
      frame.tree.parentNode.replaceChild(this.render(), frame.tree);
    }
  }

  render(frame?: ViewFrame): Content {
    if (frame) return <Content>this.renderer(frame).tree;
    this.frame = this.renderer(new ViewFrame());
    return <Content>this.frame.tree;
  }
}
