"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* The property-seek module literally copied and pasted here for conveinence. */
var source = "\nfunction $$boundary_to_dot(value) {\n  return value.split('][').join('.').split('[').join('.');\n}\n\nfunction $$strip_braces(value) {\n  return value.split('[').join('.').split(']').join('');\n}\n\nfunction $$escape_dots(value) {\n  value = value.split('\\'');\n  return (value.length < 3) ? value.join('\\'') : value.map(function(seg) {\n    if (seg.length < 3) return seg;\n    if ((seg[0] === '.') || (seg[seg.length - 1] === '.')) return seg;\n    return seg.split('.').join('&&');\n  }).join('');\n}\n\nfunction $$unescape_dots(value) {\n  return value.split('&&').join('.');\n}\n\nfunction $$partify(value) {\n  if (!value) return;\n  return $$escape_dots($$strip_braces($$boundary_to_dot('' + value))).split('.');\n}\n\nfunction $$property(path, o) {\n\n  var parts = $$partify(path);\n  var first;\n\n  if (typeof o !== 'object')\n    throw new TypeError('get(): expects an object got ' + typeof o);\n\n  if (parts.length === 1) return o[$$unescape_dots(parts[0])];\n  if (parts.length === 0) return;\n\n  first = o[parts.shift()];\n\n  return ((typeof o === 'object') && (o !== null)) ?\n\n    parts.reduce(function(target, prop) {\n      if (target == null) return target;\n      return target[$$unescape_dots(prop)];\n    }, first) : null;\n}\n\nfunction $$adopt(child, e) {\n\n    if (Array.isArray(child))\n      return child.forEach(innerChild => $$adopt(innerChild, e));\n\n    if (child)\n      e.appendChild(\n        (typeof child === 'object') ?\n        child : document.createTextNode(child || ''));\n\n}\n\n/**\n * $$register a Widget or Node by the specified wml:id\n * @param {string} id\n * @param {Widget|Node} target\n * @param {object} ids\n */\nfunction $$register(id, target, ids) {\n\n  if (ids.hasOwnProperty(id))\n    throw new Error('Duplicate id \\'' +id+'\\' detected!');\n\n  ids[id] = target;\n\n  return target;\n\n}\n\n/**\n * $$text creates a DOMTextNode\n * @param {string} value\n */\nfunction $$text(value) {\n\n  return document.createTextNode(value || '');\n\n}\n\n/**\n * $$resolve property access expression to avoid\n * thowing errors if it does not exist.\n * @param {object} head\n * @param {string} path\n */\nfunction $$resolve(head, path) {\n\n  var ret = $$property(head, path);\n\n  return (ret == null) ? '' : ret;\n\n}\n\n/**\n * $$node is called to create a regular DOM node\n * @param {string} tag\n * @param {object} attributes\n * @param {array<string|number|Widget>} children\n * @param {View} view\n */\nfunction $$node(tag, attributes, children, view) {\n\n  var e = (tag === 'fragment') ? document.createDocumentFragment() : document.createElement(tag);\n\n  if (typeof attributes.html === 'object')\n    Object.keys(attributes.html).forEach(key => {\n\n      if (typeof attributes.html[key] === 'function') {\n        e[key] = attributes.html[key];\n      } else {\n        e.setAttribute(key, attributes.html[key]);\n      }\n    });\n\n  children.forEach(c => $$adopt(c, e));\n\n  if (attributes.wml)\n    if (attributes.wml.id)\n      $$register(attributes.wml.id, e, view.ids);\n\n  return e;\n\n}\n\n/**\n * Attributes provides an API for reading the\n * attributes supplied to an Element.\n * @param {object} attrs\n */\nclass Attributes {\n\n    constructor(attrs) {\n\n        this._attrs = attrs;\n\n    }\n\n    static isset(value) {\n\n      return [null, undefined].indexOf(value) < 0;\n\n    }\n\n    /**\n     * read a value form the internal list.\n     * @param {string} path\n     * @param {*} defaultValue - This value is returned if the value is not set.\n     */\n    read(path, defaultValue) {\n\n        var ret = $$property(this._attrs, path.split(':').join('.'));\n\n        defaultValue = Attributes.isset(defaultValue)? defaultValue : '';\n\n        if(!Attributes.isset(ret))\n            return defaultValue;\n\n        return ret;\n\n    }\n\n    /**\n     * require is like read but throws an Error if the value is not supplied.\n     * @param {string} path\n     * @returns {*}\n     */\n    require(path) {\n\n        var ret = this.read(path);\n\n        if(!Attributes.isset(ret))\n            throw new ReferenceError(`${path} is required!`);\n\n        return ret;\n\n    }\n\n    /**\n     * requireArray requires the value to be an array, if no\n     * value is read then default is provided.\n     * @param {string} path\n     * @param {*} defaultValue\n     */\n    requireArray(path, defaultValue) {\n\n        var ret = this.read(path);\n\n        if(!Attributes.isset(ret)) {\n\n            if (Attributes.isset(defaultValue))\n                return defaultValue;\n\n            throw new ReferenceError(`${path} is required!`);\n\n        } else {\n\n            if (Array.isArray(ret))\n                return ret;\n\n            throw new TypeError(`${path} must be an array got ${typeof ret}!`);\n\n        }\n\n    }\n\n\n}\n\n\n/**\n * $$widget creates a wml widget.\n * @param {function} Construtor\n * @param {object} attributes\n * @param {array<string|number|Widget>} children\n * @param {View} view\n * @return {Widget}\n */\nfunction $$widget(Constructor, attributes, children, view) {\n\n  var childs = [];\n  var w;\n\n  children.forEach(child => Array.isArray(child) ?\n    childs.push.apply(childs, child) : childs.push(child));\n\n  w = new Constructor(new Attributes(attributes), childs);\n\n  if (attributes.wml)\n    if (attributes.wml.id)\n      $$register(attributes.wml.id, w, view.ids);\n\n  this.widgets.push(w);\n  return w.render();\n\n}\n\n/**\n * $$if is called to create an if conditional construct\n * @param {*} predicate\n * @param {function} positive\n * @param {function} negative\n */\nfunction $$if(predicate, positive, negative) {\n\n  return (predicate) ? positive() : negative();\n\n}\n\n/**\n * $$for is called to create a for loop construct\n * @param {Iterable} collection\n * @param {function} cb\n */\nfunction $$for(collection, cb) {\n\n  if (Array.isArray(collection)) {\n\n    return collection.map(cb);\n\n   } else if (typeof collection === 'object') {\n\n     return Object.keys(collection).map((key, i, all) => cb(collection[key], key, all));\n\n   }\n\n    return [];\n\n}\n\n/**\n * $$switch simulates a switch statement\n * @param {string|number|boolean} value\n * @param {object} cases\n */\nfunction $$switch(value, cases) {\n\n    var result = cases[value];\n    var defaul = cases.default;\n\n    if (result) return result;\n\n    if (defaul) return defaul;\n\n}\n";

exports.default = function () {
  return source;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXIvcHJlYW1ibGUuanMiXSwibmFtZXMiOlsic291cmNlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsSUFBTUEsZ3pNQUFOOztrQkFzU2dCO0FBQUEsU0FBTUEsTUFBTjtBQUFBLEMiLCJmaWxlIjoicHJlYW1ibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBUaGUgcHJvcGVydHktc2VlayBtb2R1bGUgbGl0ZXJhbGx5IGNvcGllZCBhbmQgcGFzdGVkIGhlcmUgZm9yIGNvbnZlaW5lbmNlLiAqL1xuY29uc3Qgc291cmNlID0gYFxuZnVuY3Rpb24gJCRib3VuZGFyeV90b19kb3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KCddWycpLmpvaW4oJy4nKS5zcGxpdCgnWycpLmpvaW4oJy4nKTtcbn1cblxuZnVuY3Rpb24gJCRzdHJpcF9icmFjZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KCdbJykuam9pbignLicpLnNwbGl0KCddJykuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uICQkZXNjYXBlX2RvdHModmFsdWUpIHtcbiAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnXFxcXCcnKTtcbiAgcmV0dXJuICh2YWx1ZS5sZW5ndGggPCAzKSA/IHZhbHVlLmpvaW4oJ1xcXFwnJykgOiB2YWx1ZS5tYXAoZnVuY3Rpb24oc2VnKSB7XG4gICAgaWYgKHNlZy5sZW5ndGggPCAzKSByZXR1cm4gc2VnO1xuICAgIGlmICgoc2VnWzBdID09PSAnLicpIHx8IChzZWdbc2VnLmxlbmd0aCAtIDFdID09PSAnLicpKSByZXR1cm4gc2VnO1xuICAgIHJldHVybiBzZWcuc3BsaXQoJy4nKS5qb2luKCcmJicpO1xuICB9KS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gJCR1bmVzY2FwZV9kb3RzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5zcGxpdCgnJiYnKS5qb2luKCcuJyk7XG59XG5cbmZ1bmN0aW9uICQkcGFydGlmeSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSByZXR1cm47XG4gIHJldHVybiAkJGVzY2FwZV9kb3RzKCQkc3RyaXBfYnJhY2VzKCQkYm91bmRhcnlfdG9fZG90KCcnICsgdmFsdWUpKSkuc3BsaXQoJy4nKTtcbn1cblxuZnVuY3Rpb24gJCRwcm9wZXJ0eShwYXRoLCBvKSB7XG5cbiAgdmFyIHBhcnRzID0gJCRwYXJ0aWZ5KHBhdGgpO1xuICB2YXIgZmlyc3Q7XG5cbiAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXQoKTogZXhwZWN0cyBhbiBvYmplY3QgZ290ICcgKyB0eXBlb2Ygbyk7XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIG9bJCR1bmVzY2FwZV9kb3RzKHBhcnRzWzBdKV07XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICBmaXJzdCA9IG9bcGFydHMuc2hpZnQoKV07XG5cbiAgcmV0dXJuICgodHlwZW9mIG8gPT09ICdvYmplY3QnKSAmJiAobyAhPT0gbnVsbCkpID9cblxuICAgIHBhcnRzLnJlZHVjZShmdW5jdGlvbih0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHJldHVybiB0YXJnZXRbJCR1bmVzY2FwZV9kb3RzKHByb3ApXTtcbiAgICB9LCBmaXJzdCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiAkJGFkb3B0KGNoaWxkLCBlKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpXG4gICAgICByZXR1cm4gY2hpbGQuZm9yRWFjaChpbm5lckNoaWxkID0+ICQkYWRvcHQoaW5uZXJDaGlsZCwgZSkpO1xuXG4gICAgaWYgKGNoaWxkKVxuICAgICAgZS5hcHBlbmRDaGlsZChcbiAgICAgICAgKHR5cGVvZiBjaGlsZCA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgY2hpbGQgOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZCB8fCAnJykpO1xuXG59XG5cbi8qKlxuICogJCRyZWdpc3RlciBhIFdpZGdldCBvciBOb2RlIGJ5IHRoZSBzcGVjaWZpZWQgd21sOmlkXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7V2lkZ2V0fE5vZGV9IHRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IGlkc1xuICovXG5mdW5jdGlvbiAkJHJlZ2lzdGVyKGlkLCB0YXJnZXQsIGlkcykge1xuXG4gIGlmIChpZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIGlkIFxcXFwnJyAraWQrJ1xcXFwnIGRldGVjdGVkIScpO1xuXG4gIGlkc1tpZF0gPSB0YXJnZXQ7XG5cbiAgcmV0dXJuIHRhcmdldDtcblxufVxuXG4vKipcbiAqICQkdGV4dCBjcmVhdGVzIGEgRE9NVGV4dE5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiAkJHRleHQodmFsdWUpIHtcblxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgfHwgJycpO1xuXG59XG5cbi8qKlxuICogJCRyZXNvbHZlIHByb3BlcnR5IGFjY2VzcyBleHByZXNzaW9uIHRvIGF2b2lkXG4gKiB0aG93aW5nIGVycm9ycyBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBoZWFkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICovXG5mdW5jdGlvbiAkJHJlc29sdmUoaGVhZCwgcGF0aCkge1xuXG4gIHZhciByZXQgPSAkJHByb3BlcnR5KGhlYWQsIHBhdGgpO1xuXG4gIHJldHVybiAocmV0ID09IG51bGwpID8gJycgOiByZXQ7XG5cbn1cblxuLyoqXG4gKiAkJG5vZGUgaXMgY2FsbGVkIHRvIGNyZWF0ZSBhIHJlZ3VsYXIgRE9NIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge2FycmF5PHN0cmluZ3xudW1iZXJ8V2lkZ2V0Pn0gY2hpbGRyZW5cbiAqIEBwYXJhbSB7Vmlld30gdmlld1xuICovXG5mdW5jdGlvbiAkJG5vZGUodGFnLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuXG4gIHZhciBlID0gKHRhZyA9PT0gJ2ZyYWdtZW50JykgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmh0bWwgPT09ICdvYmplY3QnKVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMuaHRtbCkuZm9yRWFjaChrZXkgPT4ge1xuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuaHRtbFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVba2V5XSA9IGF0dHJpYnV0ZXMuaHRtbFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzLmh0bWxba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgY2hpbGRyZW4uZm9yRWFjaChjID0+ICQkYWRvcHQoYywgZSkpO1xuXG4gIGlmIChhdHRyaWJ1dGVzLndtbClcbiAgICBpZiAoYXR0cmlidXRlcy53bWwuaWQpXG4gICAgICAkJHJlZ2lzdGVyKGF0dHJpYnV0ZXMud21sLmlkLCBlLCB2aWV3Lmlkcyk7XG5cbiAgcmV0dXJuIGU7XG5cbn1cblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHByb3ZpZGVzIGFuIEFQSSBmb3IgcmVhZGluZyB0aGVcbiAqIGF0dHJpYnV0ZXMgc3VwcGxpZWQgdG8gYW4gRWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyc1xuICovXG5jbGFzcyBBdHRyaWJ1dGVzIHtcblxuICAgIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG5cbiAgICAgICAgdGhpcy5fYXR0cnMgPSBhdHRycztcblxuICAgIH1cblxuICAgIHN0YXRpYyBpc3NldCh2YWx1ZSkge1xuXG4gICAgICByZXR1cm4gW251bGwsIHVuZGVmaW5lZF0uaW5kZXhPZih2YWx1ZSkgPCAwO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVhZCBhIHZhbHVlIGZvcm0gdGhlIGludGVybmFsIGxpc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSAtIFRoaXMgdmFsdWUgaXMgcmV0dXJuZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gICAgICovXG4gICAgcmVhZChwYXRoLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgICAgICB2YXIgcmV0ID0gJCRwcm9wZXJ0eSh0aGlzLl9hdHRycywgcGF0aC5zcGxpdCgnOicpLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gQXR0cmlidXRlcy5pc3NldChkZWZhdWx0VmFsdWUpPyBkZWZhdWx0VmFsdWUgOiAnJztcblxuICAgICAgICBpZighQXR0cmlidXRlcy5pc3NldChyZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVxdWlyZSBpcyBsaWtlIHJlYWQgYnV0IHRocm93cyBhbiBFcnJvciBpZiB0aGUgdmFsdWUgaXMgbm90IHN1cHBsaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgcmVxdWlyZShwYXRoKSB7XG5cbiAgICAgICAgdmFyIHJldCA9IHRoaXMucmVhZChwYXRoKTtcblxuICAgICAgICBpZighQXR0cmlidXRlcy5pc3NldChyZXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcYFxcJHtwYXRofSBpcyByZXF1aXJlZCFcXGApO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXF1aXJlQXJyYXkgcmVxdWlyZXMgdGhlIHZhbHVlIHRvIGJlIGFuIGFycmF5LCBpZiBub1xuICAgICAqIHZhbHVlIGlzIHJlYWQgdGhlbiBkZWZhdWx0IGlzIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWVcbiAgICAgKi9cbiAgICByZXF1aXJlQXJyYXkocGF0aCwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICAgICAgdmFyIHJldCA9IHRoaXMucmVhZChwYXRoKTtcblxuICAgICAgICBpZighQXR0cmlidXRlcy5pc3NldChyZXQpKSB7XG5cbiAgICAgICAgICAgIGlmIChBdHRyaWJ1dGVzLmlzc2V0KGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcYFxcJHtwYXRofSBpcyByZXF1aXJlZCFcXGApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXGBcXCR7cGF0aH0gbXVzdCBiZSBhbiBhcnJheSBnb3QgXFwke3R5cGVvZiByZXR9IVxcYCk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbn1cblxuXG4vKipcbiAqICQkd2lkZ2V0IGNyZWF0ZXMgYSB3bWwgd2lkZ2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ29uc3RydXRvclxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nfG51bWJlcnxXaWRnZXQ+fSBjaGlsZHJlblxuICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gKiBAcmV0dXJuIHtXaWRnZXR9XG4gKi9cbmZ1bmN0aW9uICQkd2lkZ2V0KENvbnN0cnVjdG9yLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuXG4gIHZhciBjaGlsZHMgPSBbXTtcbiAgdmFyIHc7XG5cbiAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBBcnJheS5pc0FycmF5KGNoaWxkKSA/XG4gICAgY2hpbGRzLnB1c2guYXBwbHkoY2hpbGRzLCBjaGlsZCkgOiBjaGlsZHMucHVzaChjaGlsZCkpO1xuXG4gIHcgPSBuZXcgQ29uc3RydWN0b3IobmV3IEF0dHJpYnV0ZXMoYXR0cmlidXRlcyksIGNoaWxkcyk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMud21sKVxuICAgIGlmIChhdHRyaWJ1dGVzLndtbC5pZClcbiAgICAgICQkcmVnaXN0ZXIoYXR0cmlidXRlcy53bWwuaWQsIHcsIHZpZXcuaWRzKTtcblxuICB0aGlzLndpZGdldHMucHVzaCh3KTtcbiAgcmV0dXJuIHcucmVuZGVyKCk7XG5cbn1cblxuLyoqXG4gKiAkJGlmIGlzIGNhbGxlZCB0byBjcmVhdGUgYW4gaWYgY29uZGl0aW9uYWwgY29uc3RydWN0XG4gKiBAcGFyYW0geyp9IHByZWRpY2F0ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gcG9zaXRpdmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG5lZ2F0aXZlXG4gKi9cbmZ1bmN0aW9uICQkaWYocHJlZGljYXRlLCBwb3NpdGl2ZSwgbmVnYXRpdmUpIHtcblxuICByZXR1cm4gKHByZWRpY2F0ZSkgPyBwb3NpdGl2ZSgpIDogbmVnYXRpdmUoKTtcblxufVxuXG4vKipcbiAqICQkZm9yIGlzIGNhbGxlZCB0byBjcmVhdGUgYSBmb3IgbG9vcCBjb25zdHJ1Y3RcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gKi9cbmZ1bmN0aW9uICQkZm9yKGNvbGxlY3Rpb24sIGNiKSB7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcblxuICAgIHJldHVybiBjb2xsZWN0aW9uLm1hcChjYik7XG5cbiAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdvYmplY3QnKSB7XG5cbiAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbGxlY3Rpb24pLm1hcCgoa2V5LCBpLCBhbGwpID0+IGNiKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBhbGwpKTtcblxuICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuXG59XG5cbi8qKlxuICogJCRzd2l0Y2ggc2ltdWxhdGVzIGEgc3dpdGNoIHN0YXRlbWVudFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gY2FzZXNcbiAqL1xuZnVuY3Rpb24gJCRzd2l0Y2godmFsdWUsIGNhc2VzKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gY2FzZXNbdmFsdWVdO1xuICAgIHZhciBkZWZhdWwgPSBjYXNlcy5kZWZhdWx0O1xuXG4gICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcblxuICAgIGlmIChkZWZhdWwpIHJldHVybiBkZWZhdWw7XG5cbn1cbmA7XG5cbmV4cG9ydCBkZWZhdWx0ICAoKSA9PiBzb3VyY2U7XG5cbiJdfQ==