'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* The property-seek module literally copied and pasted here for conveinence. */

var _ts = function _ts(o, txt) {
  var dtxt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return o.typescript ? txt : dtxt;
};

var _typescriptProperties = function _typescriptProperties() {
  return '\n  ids: {[key:string]: WMLElement};\n  widgets: Widget[];\n  tree: HTMLElement;\n  context: object;\n  template: ()=>HTMLElement;\n';
};

var _view = function _view() {
  return '\n\nexport interface View {\n\n render(): HTMLElement;\n findById(id:string): WMLElement;\n\n}';
};

var _widget = function _widget() {
  return '\nexport interface Widget {\n\n  rendered(): void;\n  removed(): void;\n  render(): HTMLElement;\n\n}';
};

var _element = function _element() {
  return 'export type WMLElement = HTMLElement | Node | EventTarget | Widget';
};

var preamble = exports.preamble = function preamble(o) {
  return '\n\nfunction $$boundary_to_dot(value) {\n  return value.split(\'][\').join(\'.\').split(\'[\').join(\'.\');\n}\n\nfunction $$strip_braces(value) {\n  return value.split(\'[\').join(\'.\').split(\']\').join(\'\');\n}\n\nfunction $$escape_dots(value) {\n  value = value.split(\'\\\'\');\n  return (value.length < 3) ? value.join(\'\\\'\') : value.map(function(seg) {\n    if (seg.length < 3) return seg;\n    if ((seg[0] === \'.\') || (seg[seg.length - 1] === \'.\')) return seg;\n    return seg.split(\'.\').join(\'&&\');\n  }).join(\'\');\n}\n\nfunction $$unescape_dots(value) {\n  return value.split(\'&&\').join(\'.\');\n}\n\nfunction $$partify(value) {\n  if (!value) return;\n  return $$escape_dots($$strip_braces($$boundary_to_dot(\'\' + value))).split(\'.\');\n}\n\nfunction $$property(path, o) {\n\n  var parts = $$partify(path);\n  var first;\n\n  if (typeof o !== \'object\')\n    throw new TypeError(\'get(): expects an object got \' + typeof o);\n\n  if (parts.length === 1) return o[$$unescape_dots(parts[0])];\n  if (parts.length === 0) return;\n\n  first = o[parts.shift()];\n\n  return ((typeof o === \'object\') && (o !== null)) ?\n\n    parts.reduce(function(target, prop) {\n      if (target == null) return target;\n      return target[$$unescape_dots(prop)];\n    }, first) : null;\n}\n\nfunction $$adopt(child, e) {\n\n    if (Array.isArray(child))\n      return child.forEach(innerChild => $$adopt(innerChild, e));\n\n    if (child)\n      e.appendChild(\n        (typeof child === \'object\') ?\n        child : document.createTextNode(child == null? \'\' : child));\n\n}\n\n/**\n * $$text creates a DOMTextNode\n * @param {string} value\n */\nfunction $$text(value) {\n\n  return document.createTextNode(value == null ?  \'\' : value);\n\n}\n\n/**\n * $$resolve property access expression to avoid\n * thowing errors if it does not exist.\n * @param {object} head\n * @param {string} path\n */\nfunction $$resolve(head, path) {\n\n    if((head == null) || head == \'\')\n        return \'\';\n\n  var ret = $$property(path, head);\n\n  return (ret == null) ? \'\' : ret;\n\n}\n\n/**\n * $$node is called to create a regular DOM node\n * @param {string} tag\n * @param {object} attributes\n * @param {array<string|number|Widget>} children\n * @param {View} view\n */\nfunction $$node(tag, attributes, children, view) {\n\n  var e = (tag === \'fragment\') ? document.createDocumentFragment() : document.createElement(tag);\n\n  if (typeof attributes.html === \'object\')\n    Object.keys(attributes.html).forEach(key => {\n\n      if (typeof attributes.html[key] === \'function\') {\n        e[key] = attributes.html[key];\n      } else {\n        e.setAttribute(key, attributes.html[key]);\n      }\n    });\n\n  children.forEach(c => $$adopt(c, e));\n\n  if (attributes.wml)\n    if (attributes.wml.id)\n      view.register(attributes.wml.id, e);\n\n  return e;\n\n}\n\n/**\n * Attributes provides an API for reading the\n * attributes supplied to an Element.\n * @param {object} attrs\n */\nclass Attributes {\n\n    constructor(' + _ts(o, 'public _attrs:any', '_attrs') + ') {\n\n        this._attrs = _attrs;\n\n    }\n\n    ' + _ts(o, 'has(path:string): boolean', 'has(path)') + '{\n\n      return this.read(path) != null;\n\n    }\n\n    /**\n     * read a value form the internal list.\n     * @param {string} path\n     * @param {*} defaultValue - This value is returned if the value is not set.\n     */\n    ' + _ts(o, 'read<A>(path:string, defaultValue?:A): A', 'read(path, defaultValue)') + ' {\n\n        var ret = $$property(path.split(\':\').join(\'.\'), this._attrs);\n      return (ret != null) ? ret : (defaultValue != null) ? defaultValue : \'\';\n\n    }\n\n}\n\n\n/**\n * $$widget creates a wml widget.\n * @param {function} Construtor\n * @param {object} attributes\n * @param {array<string|number|Widget>} children\n * @param {View} view\n * @return {Widget}\n */\nfunction $$widget(Constructor, attributes, children, view) {\n\n  var childs = [];\n  var w;\n\n  children.forEach(child => Array.isArray(child) ?\n    childs.push.apply(childs, child) : childs.push(child));\n\n  w = new Constructor(new Attributes(attributes), childs);\n\n  if (attributes.wml)\n    if (attributes.wml.id)\n      view.register(attributes.wml.id, w);\n\n  view.widgets.push(w);\n  return w.render();\n\n}\n\n/**\n * $$if is called to create an if conditional construct\n * @param {*} predicate\n * @param {function} positive\n * @param {function} negative\n */\nfunction $$if(predicate, positive, negative) {\n\n  return (predicate) ? positive() : negative();\n\n}\n\n/**\n * $$for is called to create a for loop construct\n * @param {Iterable} collection\n * @param {function} cb\n */\nfunction $$for(collection, cb) {\n\n  if (Array.isArray(collection)) {\n\n    return collection.map(cb);\n\n   } else if (typeof collection === \'object\') {\n\n     return Object.keys(collection).map((key, _, all) => cb(collection[key], key, all));\n\n   }\n\n    return [];\n\n}\n\n/**\n * $$switch simulates a switch statement\n * @param {string|number|boolean} value\n * @param {object} cases\n */\nfunction $$switch(value, cases) {\n\n    var result = cases[value];\n    var defaul = cases.default;\n\n    if (result) return result;\n\n    if (defaul) return defaul;\n\n}\n\n' + _ts(o, _view()) + '\n' + _ts(o, _widget()) + '\n' + _ts(o, _element());
};

var _rootElement = function _rootElement(root, o) {
  return root ? root.transpile(o) : o.typescript ? '<HTMLElement><Node>document.createDocumentFragment()' : 'document.createDocumentFragment()';
};

var view = exports.view = function view(name, tag, o) {
  return 'export class ' + name + ' ' + (o.typescript ? 'implements View' : '') + '{\n\n      ' + (o.typescript ? _typescriptProperties() : '') + '\n\n       constructor(context) {\n\n          let view = this;\n\n          this.ids = {};\n          this.widgets = [];\n\n          this.tree = null;\n          this.context = context;\n          this.template = function(){\n            return ' + _rootElement(tag, o) + '\n          }\n\n       }\n\n       static render(context) {\n\n         return (new ' + name + '(context)).render();\n\n       }\n\n       ' + (o.typescript ? 'register(id:string, w:WMLElement): ' + name : 'register(id, w)') + '{\n\n\n         if (this.ids.hasOwnProperty(id))\n           throw new Error(\'Duplicate id \\\'\' +id+\'\\\' detected!\');\n\n         this.ids[id] = w;\n         return this;\n\n       }\n\n       ' + (o.typescript ? 'findById(id:string) : WMLElement ' : 'findById(id)') + '{\n\n        return (this.ids[id]) ? this.ids[id] : null;\n\n       }\n\n       ' + (o.typescript ? 'invalidate(): void' : 'invalidate()') + ' {\n\n        var childs;\n        var parent = this.tree.parentNode;\n        var realFirstChild;\n        var realFirstChildIndex;\n\n         if (this.tree == null)\n           throw new ReferenceError(\'Cannot invalidate a view that has not been rendered!\');\n\n         if (this.tree.parentNode == null)\n           throw new ReferenceError(\'Attempt to invalidate a view that has not been inserted to DOM!\');\n\n         childs = ' + (o.typescript ? '(<Element> this.tree.parentNode)' : 'this.tree.parentNode') + '.children;\n\n         //for some reason the reference stored does not have the correct parent node.\n         //we do this to get a \'live\' version of the node.\n         for (let i = 0; i < childs.length; i++)\n           if (childs[i] === this.tree) {\n             realFirstChild = childs[i];\n             realFirstChildIndex = i;\n           }\n\n         parent.replaceChild(this.render(), realFirstChild);\n\n       }\n\n       render() {\n\n        this.ids = {};\n        this.widgets.forEach(w => w.removed());\n        this.widgets = [];\n        this.tree = this.template.call(this.context);\n        this.ids[\'root\'] = (this.ids[\'root\'])? this.ids[\'root\']:this.tree;\n        this.widgets.forEach(w => w.rendered());\n\n        return this.tree;\n\n      }\n\n     }\n\n    ';
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wYXJzZXIvVGVtcGxhdGVzLmpzIl0sIm5hbWVzIjpbIl90cyIsIm8iLCJ0eHQiLCJkdHh0IiwidHlwZXNjcmlwdCIsIl90eXBlc2NyaXB0UHJvcGVydGllcyIsIl92aWV3IiwiX3dpZGdldCIsIl9lbGVtZW50IiwicHJlYW1ibGUiLCJfcm9vdEVsZW1lbnQiLCJyb290IiwidHJhbnNwaWxlIiwidmlldyIsIm5hbWUiLCJ0YWciXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUEsSUFBTUEsTUFBTSxTQUFOQSxHQUFNLENBQUNDLENBQUQsRUFBSUMsR0FBSjtBQUFBLE1BQVNDLElBQVQsdUVBQWdCLEVBQWhCO0FBQUEsU0FBdUJGLEVBQUVHLFVBQUYsR0FBZUYsR0FBZixHQUFxQkMsSUFBNUM7QUFBQSxDQUFaOztBQUVBLElBQU1FLHdCQUF3QixTQUF4QkEscUJBQXdCO0FBQUE7QUFBQSxDQUE5Qjs7QUFTQSxJQUFNQyxRQUFRLFNBQVJBLEtBQVE7QUFBQTtBQUFBLENBQWQ7O0FBU0EsSUFBTUMsVUFBVSxTQUFWQSxPQUFVO0FBQUE7QUFBQSxDQUFoQjs7QUFTQSxJQUFNQyxXQUFXLFNBQVhBLFFBQVc7QUFBQTtBQUFBLENBQWpCOztBQUdPLElBQU1DLDhCQUFXLFNBQVhBLFFBQVc7QUFBQSw0L0ZBOEhOVCxJQUFJQyxDQUFKLEVBQU8sbUJBQVAsRUFBNkIsUUFBN0IsQ0E5SE0sNkRBb0lsQkQsSUFBSUMsQ0FBSixFQUFPLDJCQUFQLEVBQW9DLFdBQXBDLENBcElrQixpUEErSWxCRCxJQUFJQyxDQUFKLEVBQU8sMENBQVAsRUFBbUQsMEJBQW5ELENBL0lrQiwrdURBcU90QkQsSUFBSUMsQ0FBSixFQUFPSyxPQUFQLENBck9zQixVQXNPdEJOLElBQUlDLENBQUosRUFBT00sU0FBUCxDQXRPc0IsVUF1T3RCUCxJQUFJQyxDQUFKLEVBQU9PLFVBQVAsQ0F2T3NCO0FBQUEsQ0FBakI7O0FBeU9QLElBQU1FLGVBQWUsU0FBZkEsWUFBZSxDQUFDQyxJQUFELEVBQU9WLENBQVA7QUFBQSxTQUNuQlUsT0FBT0EsS0FBS0MsU0FBTCxDQUFlWCxDQUFmLENBQVAsR0FBNEJBLEVBQUVHLFVBQUgsR0FDM0Isc0RBRDJCLEdBRTNCLG1DQUhtQjtBQUFBLENBQXJCOztBQUtPLElBQU1TLHNCQUFPLFNBQVBBLElBQU8sQ0FBQ0MsSUFBRCxFQUFPQyxHQUFQLEVBQVlkLENBQVo7QUFBQSwyQkFFRmEsSUFGRSxVQUVNYixFQUFFRyxVQUFGLEdBQWMsaUJBQWQsR0FBa0MsRUFGeEMscUJBSVhILEVBQUVHLFVBQUgsR0FBZ0JDLHVCQUFoQixHQUEwQyxFQUo5QixnUUFnQkNLLGFBQWFLLEdBQWIsRUFBa0JkLENBQWxCLENBaEJELDZGQXVCR2EsSUF2Qkgsb0RBMkJYYixFQUFFRyxVQUFGLEdBQWMsd0NBQXNDVSxJQUFwRCxHQUEyRCxpQkEzQmhELGlOQXNDWGIsRUFBRUcsVUFBRixHQUFjLG1DQUFkLEdBQW9ELGNBdEN6QywwRkE0Q1hILEVBQUVHLFVBQUYsR0FBYyxvQkFBZCxHQUFxQyxjQTVDMUIsZ2NBeURBSCxFQUFFRyxVQUFGLEdBQWMsa0NBQWQsR0FBbUQsc0JBekRuRDtBQUFBLENBQWIiLCJmaWxlIjoiVGVtcGxhdGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIHByb3BlcnR5LXNlZWsgbW9kdWxlIGxpdGVyYWxseSBjb3BpZWQgYW5kIHBhc3RlZCBoZXJlIGZvciBjb252ZWluZW5jZS4gKi9cblxuY29uc3QgX3RzID0gKG8sIHR4dCwgZHR4dCA9ICcnKSA9PiBvLnR5cGVzY3JpcHQgPyB0eHQgOiBkdHh0O1xuXG5jb25zdCBfdHlwZXNjcmlwdFByb3BlcnRpZXMgPSAoKSA9PiBgXG4gIGlkczoge1trZXk6c3RyaW5nXTogV01MRWxlbWVudH07XG4gIHdpZGdldHM6IFdpZGdldFtdO1xuICB0cmVlOiBIVE1MRWxlbWVudDtcbiAgY29udGV4dDogb2JqZWN0O1xuICB0ZW1wbGF0ZTogKCk9PkhUTUxFbGVtZW50O1xuYDtcblxuXG5jb25zdCBfdmlldyA9ICgpID0+IGBcblxuZXhwb3J0IGludGVyZmFjZSBWaWV3IHtcblxuIHJlbmRlcigpOiBIVE1MRWxlbWVudDtcbiBmaW5kQnlJZChpZDpzdHJpbmcpOiBXTUxFbGVtZW50O1xuXG59YDtcblxuY29uc3QgX3dpZGdldCA9ICgpID0+IGBcbmV4cG9ydCBpbnRlcmZhY2UgV2lkZ2V0IHtcblxuICByZW5kZXJlZCgpOiB2b2lkO1xuICByZW1vdmVkKCk6IHZvaWQ7XG4gIHJlbmRlcigpOiBIVE1MRWxlbWVudDtcblxufWA7XG5cbmNvbnN0IF9lbGVtZW50ID0gKCkgPT5cbiAgYGV4cG9ydCB0eXBlIFdNTEVsZW1lbnQgPSBIVE1MRWxlbWVudCB8IE5vZGUgfCBFdmVudFRhcmdldCB8IFdpZGdldGA7XG5cbmV4cG9ydCBjb25zdCBwcmVhbWJsZSA9IG8gPT4gYFxuXG5mdW5jdGlvbiAkJGJvdW5kYXJ5X3RvX2RvdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoJ11bJykuam9pbignLicpLnNwbGl0KCdbJykuam9pbignLicpO1xufVxuXG5mdW5jdGlvbiAkJHN0cmlwX2JyYWNlcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuc3BsaXQoJ1snKS5qb2luKCcuJykuc3BsaXQoJ10nKS5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gJCRlc2NhcGVfZG90cyh2YWx1ZSkge1xuICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCdcXFxcJycpO1xuICByZXR1cm4gKHZhbHVlLmxlbmd0aCA8IDMpID8gdmFsdWUuam9pbignXFxcXCcnKSA6IHZhbHVlLm1hcChmdW5jdGlvbihzZWcpIHtcbiAgICBpZiAoc2VnLmxlbmd0aCA8IDMpIHJldHVybiBzZWc7XG4gICAgaWYgKChzZWdbMF0gPT09ICcuJykgfHwgKHNlZ1tzZWcubGVuZ3RoIC0gMV0gPT09ICcuJykpIHJldHVybiBzZWc7XG4gICAgcmV0dXJuIHNlZy5zcGxpdCgnLicpLmpvaW4oJyYmJyk7XG4gIH0pLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiAkJHVuZXNjYXBlX2RvdHModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KCcmJicpLmpvaW4oJy4nKTtcbn1cblxuZnVuY3Rpb24gJCRwYXJ0aWZ5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybjtcbiAgcmV0dXJuICQkZXNjYXBlX2RvdHMoJCRzdHJpcF9icmFjZXMoJCRib3VuZGFyeV90b19kb3QoJycgKyB2YWx1ZSkpKS5zcGxpdCgnLicpO1xufVxuXG5mdW5jdGlvbiAkJHByb3BlcnR5KHBhdGgsIG8pIHtcblxuICB2YXIgcGFydHMgPSAkJHBhcnRpZnkocGF0aCk7XG4gIHZhciBmaXJzdDtcblxuICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldCgpOiBleHBlY3RzIGFuIG9iamVjdCBnb3QgJyArIHR5cGVvZiBvKTtcblxuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gb1skJHVuZXNjYXBlX2RvdHMocGFydHNbMF0pXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIGZpcnN0ID0gb1twYXJ0cy5zaGlmdCgpXTtcblxuICByZXR1cm4gKCh0eXBlb2YgbyA9PT0gJ29iamVjdCcpICYmIChvICE9PSBudWxsKSkgP1xuXG4gICAgcGFydHMucmVkdWNlKGZ1bmN0aW9uKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgcmV0dXJuIHRhcmdldFskJHVuZXNjYXBlX2RvdHMocHJvcCldO1xuICAgIH0sIGZpcnN0KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uICQkYWRvcHQoY2hpbGQsIGUpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSlcbiAgICAgIHJldHVybiBjaGlsZC5mb3JFYWNoKGlubmVyQ2hpbGQgPT4gJCRhZG9wdChpbm5lckNoaWxkLCBlKSk7XG5cbiAgICBpZiAoY2hpbGQpXG4gICAgICBlLmFwcGVuZENoaWxkKFxuICAgICAgICAodHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JykgP1xuICAgICAgICBjaGlsZCA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkID09IG51bGw/ICcnIDogY2hpbGQpKTtcblxufVxuXG4vKipcbiAqICQkdGV4dCBjcmVhdGVzIGEgRE9NVGV4dE5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiAkJHRleHQodmFsdWUpIHtcblxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgPT0gbnVsbCA/ICAnJyA6IHZhbHVlKTtcblxufVxuXG4vKipcbiAqICQkcmVzb2x2ZSBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvbiB0byBhdm9pZFxuICogdGhvd2luZyBlcnJvcnMgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gaGVhZFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqL1xuZnVuY3Rpb24gJCRyZXNvbHZlKGhlYWQsIHBhdGgpIHtcblxuICAgIGlmKChoZWFkID09IG51bGwpIHx8IGhlYWQgPT0gJycpXG4gICAgICAgIHJldHVybiAnJztcblxuICB2YXIgcmV0ID0gJCRwcm9wZXJ0eShwYXRoLCBoZWFkKTtcblxuICByZXR1cm4gKHJldCA9PSBudWxsKSA/ICcnIDogcmV0O1xuXG59XG5cbi8qKlxuICogJCRub2RlIGlzIGNhbGxlZCB0byBjcmVhdGUgYSByZWd1bGFyIERPTSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlc1xuICogQHBhcmFtIHthcnJheTxzdHJpbmd8bnVtYmVyfFdpZGdldD59IGNoaWxkcmVuXG4gKiBAcGFyYW0ge1ZpZXd9IHZpZXdcbiAqL1xuZnVuY3Rpb24gJCRub2RlKHRhZywgYXR0cmlidXRlcywgY2hpbGRyZW4sIHZpZXcpIHtcblxuICB2YXIgZSA9ICh0YWcgPT09ICdmcmFnbWVudCcpID8gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5odG1sID09PSAnb2JqZWN0JylcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzLmh0bWwpLmZvckVhY2goa2V5ID0+IHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmh0bWxba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlW2tleV0gPSBhdHRyaWJ1dGVzLmh0bWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlcy5odG1sW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIGNoaWxkcmVuLmZvckVhY2goYyA9PiAkJGFkb3B0KGMsIGUpKTtcblxuICBpZiAoYXR0cmlidXRlcy53bWwpXG4gICAgaWYgKGF0dHJpYnV0ZXMud21sLmlkKVxuICAgICAgdmlldy5yZWdpc3RlcihhdHRyaWJ1dGVzLndtbC5pZCwgZSk7XG5cbiAgcmV0dXJuIGU7XG5cbn1cblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHByb3ZpZGVzIGFuIEFQSSBmb3IgcmVhZGluZyB0aGVcbiAqIGF0dHJpYnV0ZXMgc3VwcGxpZWQgdG8gYW4gRWxlbWVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyc1xuICovXG5jbGFzcyBBdHRyaWJ1dGVzIHtcblxuICAgIGNvbnN0cnVjdG9yKCR7X3RzKG8sICdwdWJsaWMgX2F0dHJzOmFueScsICAnX2F0dHJzJyl9KSB7XG5cbiAgICAgICAgdGhpcy5fYXR0cnMgPSBfYXR0cnM7XG5cbiAgICB9XG5cbiAgICAke190cyhvLCAnaGFzKHBhdGg6c3RyaW5nKTogYm9vbGVhbicsICdoYXMocGF0aCknKX17XG5cbiAgICAgIHJldHVybiB0aGlzLnJlYWQocGF0aCkgIT0gbnVsbDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlYWQgYSB2YWx1ZSBmb3JtIHRoZSBpbnRlcm5hbCBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGlzIHZhbHVlIGlzIHJldHVybmVkIGlmIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICAgICAqL1xuICAgICR7X3RzKG8sICdyZWFkPEE+KHBhdGg6c3RyaW5nLCBkZWZhdWx0VmFsdWU/OkEpOiBBJywgJ3JlYWQocGF0aCwgZGVmYXVsdFZhbHVlKScpfSB7XG5cbiAgICAgICAgdmFyIHJldCA9ICQkcHJvcGVydHkocGF0aC5zcGxpdCgnOicpLmpvaW4oJy4nKSwgdGhpcy5fYXR0cnMpO1xuICAgICAgcmV0dXJuIChyZXQgIT0gbnVsbCkgPyByZXQgOiAoZGVmYXVsdFZhbHVlICE9IG51bGwpID8gZGVmYXVsdFZhbHVlIDogJyc7XG5cbiAgICB9XG5cbn1cblxuXG4vKipcbiAqICQkd2lkZ2V0IGNyZWF0ZXMgYSB3bWwgd2lkZ2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ29uc3RydXRvclxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nfG51bWJlcnxXaWRnZXQ+fSBjaGlsZHJlblxuICogQHBhcmFtIHtWaWV3fSB2aWV3XG4gKiBAcmV0dXJuIHtXaWRnZXR9XG4gKi9cbmZ1bmN0aW9uICQkd2lkZ2V0KENvbnN0cnVjdG9yLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbiwgdmlldykge1xuXG4gIHZhciBjaGlsZHMgPSBbXTtcbiAgdmFyIHc7XG5cbiAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBBcnJheS5pc0FycmF5KGNoaWxkKSA/XG4gICAgY2hpbGRzLnB1c2guYXBwbHkoY2hpbGRzLCBjaGlsZCkgOiBjaGlsZHMucHVzaChjaGlsZCkpO1xuXG4gIHcgPSBuZXcgQ29uc3RydWN0b3IobmV3IEF0dHJpYnV0ZXMoYXR0cmlidXRlcyksIGNoaWxkcyk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMud21sKVxuICAgIGlmIChhdHRyaWJ1dGVzLndtbC5pZClcbiAgICAgIHZpZXcucmVnaXN0ZXIoYXR0cmlidXRlcy53bWwuaWQsIHcpO1xuXG4gIHZpZXcud2lkZ2V0cy5wdXNoKHcpO1xuICByZXR1cm4gdy5yZW5kZXIoKTtcblxufVxuXG4vKipcbiAqICQkaWYgaXMgY2FsbGVkIHRvIGNyZWF0ZSBhbiBpZiBjb25kaXRpb25hbCBjb25zdHJ1Y3RcbiAqIEBwYXJhbSB7Kn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwb3NpdGl2ZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbmVnYXRpdmVcbiAqL1xuZnVuY3Rpb24gJCRpZihwcmVkaWNhdGUsIHBvc2l0aXZlLCBuZWdhdGl2ZSkge1xuXG4gIHJldHVybiAocHJlZGljYXRlKSA/IHBvc2l0aXZlKCkgOiBuZWdhdGl2ZSgpO1xuXG59XG5cbi8qKlxuICogJCRmb3IgaXMgY2FsbGVkIHRvIGNyZWF0ZSBhIGZvciBsb29wIGNvbnN0cnVjdFxuICogQHBhcmFtIHtJdGVyYWJsZX0gY29sbGVjdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcbiAqL1xuZnVuY3Rpb24gJCRmb3IoY29sbGVjdGlvbiwgY2IpIHtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ubWFwKGNiKTtcblxuICAgfSBlbHNlIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ29iamVjdCcpIHtcblxuICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29sbGVjdGlvbikubWFwKChrZXksIF8sIGFsbCkgPT4gY2IoY29sbGVjdGlvbltrZXldLCBrZXksIGFsbCkpO1xuXG4gICB9XG5cbiAgICByZXR1cm4gW107XG5cbn1cblxuLyoqXG4gKiAkJHN3aXRjaCBzaW11bGF0ZXMgYSBzd2l0Y2ggc3RhdGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjYXNlc1xuICovXG5mdW5jdGlvbiAkJHN3aXRjaCh2YWx1ZSwgY2FzZXMpIHtcblxuICAgIHZhciByZXN1bHQgPSBjYXNlc1t2YWx1ZV07XG4gICAgdmFyIGRlZmF1bCA9IGNhc2VzLmRlZmF1bHQ7XG5cbiAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuXG4gICAgaWYgKGRlZmF1bCkgcmV0dXJuIGRlZmF1bDtcblxufVxuXG4ke190cyhvLCBfdmlldygpKX1cbiR7X3RzKG8sIF93aWRnZXQoKSl9XG4ke190cyhvLCBfZWxlbWVudCgpKX1gO1xuXG5jb25zdCBfcm9vdEVsZW1lbnQgPSAocm9vdCwgbykgPT5cbiAgcm9vdCA/IHJvb3QudHJhbnNwaWxlKG8pIDogKG8udHlwZXNjcmlwdCkgP1xuICAnPEhUTUxFbGVtZW50PjxOb2RlPmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKScgOlxuICAnZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpJztcblxuZXhwb3J0IGNvbnN0IHZpZXcgPSAobmFtZSwgdGFnLCBvKSA9PlxuXG4gIGBleHBvcnQgY2xhc3MgJHtuYW1lfSAke28udHlwZXNjcmlwdD8gJ2ltcGxlbWVudHMgVmlldycgOiAnJ317XG5cbiAgICAgICR7KG8udHlwZXNjcmlwdCk/IF90eXBlc2NyaXB0UHJvcGVydGllcygpIDogJyd9XG5cbiAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG5cbiAgICAgICAgICBsZXQgdmlldyA9IHRoaXM7XG5cbiAgICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuXG4gICAgICAgICAgdGhpcy50cmVlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuICR7X3Jvb3RFbGVtZW50KHRhZywgbyl9XG4gICAgICAgICAgfVxuXG4gICAgICAgfVxuXG4gICAgICAgc3RhdGljIHJlbmRlcihjb250ZXh0KSB7XG5cbiAgICAgICAgIHJldHVybiAobmV3ICR7bmFtZX0oY29udGV4dCkpLnJlbmRlcigpO1xuXG4gICAgICAgfVxuXG4gICAgICAgJHtvLnR5cGVzY3JpcHQ/ICdyZWdpc3RlcihpZDpzdHJpbmcsIHc6V01MRWxlbWVudCk6ICcrbmFtZSA6ICdyZWdpc3RlcihpZCwgdyknfXtcblxuXG4gICAgICAgICBpZiAodGhpcy5pZHMuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBpZCBcXFxcJycgK2lkKydcXFxcJyBkZXRlY3RlZCEnKTtcblxuICAgICAgICAgdGhpcy5pZHNbaWRdID0gdztcbiAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgfVxuXG4gICAgICAgJHtvLnR5cGVzY3JpcHQ/ICdmaW5kQnlJZChpZDpzdHJpbmcpIDogV01MRWxlbWVudCAnIDogJ2ZpbmRCeUlkKGlkKSd9e1xuXG4gICAgICAgIHJldHVybiAodGhpcy5pZHNbaWRdKSA/IHRoaXMuaWRzW2lkXSA6IG51bGw7XG5cbiAgICAgICB9XG5cbiAgICAgICAke28udHlwZXNjcmlwdD8gJ2ludmFsaWRhdGUoKTogdm9pZCcgOiAnaW52YWxpZGF0ZSgpJ30ge1xuXG4gICAgICAgIHZhciBjaGlsZHM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnRyZWUucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIHJlYWxGaXJzdENoaWxkO1xuICAgICAgICB2YXIgcmVhbEZpcnN0Q2hpbGRJbmRleDtcblxuICAgICAgICAgaWYgKHRoaXMudHJlZSA9PSBudWxsKVxuICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0Nhbm5vdCBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCEnKTtcblxuICAgICAgICAgaWYgKHRoaXMudHJlZS5wYXJlbnROb2RlID09IG51bGwpXG4gICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQXR0ZW1wdCB0byBpbnZhbGlkYXRlIGEgdmlldyB0aGF0IGhhcyBub3QgYmVlbiBpbnNlcnRlZCB0byBET00hJyk7XG5cbiAgICAgICAgIGNoaWxkcyA9ICR7by50eXBlc2NyaXB0PyAnKDxFbGVtZW50PiB0aGlzLnRyZWUucGFyZW50Tm9kZSknIDogJ3RoaXMudHJlZS5wYXJlbnROb2RlJ30uY2hpbGRyZW47XG5cbiAgICAgICAgIC8vZm9yIHNvbWUgcmVhc29uIHRoZSByZWZlcmVuY2Ugc3RvcmVkIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcGFyZW50IG5vZGUuXG4gICAgICAgICAvL3dlIGRvIHRoaXMgdG8gZ2V0IGEgJ2xpdmUnIHZlcnNpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgaWYgKGNoaWxkc1tpXSA9PT0gdGhpcy50cmVlKSB7XG4gICAgICAgICAgICAgcmVhbEZpcnN0Q2hpbGQgPSBjaGlsZHNbaV07XG4gICAgICAgICAgICAgcmVhbEZpcnN0Q2hpbGRJbmRleCA9IGk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh0aGlzLnJlbmRlcigpLCByZWFsRmlyc3RDaGlsZCk7XG5cbiAgICAgICB9XG5cbiAgICAgICByZW5kZXIoKSB7XG5cbiAgICAgICAgdGhpcy5pZHMgPSB7fTtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2godyA9PiB3LnJlbW92ZWQoKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUgPSB0aGlzLnRlbXBsYXRlLmNhbGwodGhpcy5jb250ZXh0KTtcbiAgICAgICAgdGhpcy5pZHNbJ3Jvb3QnXSA9ICh0aGlzLmlkc1sncm9vdCddKT8gdGhpcy5pZHNbJ3Jvb3QnXTp0aGlzLnRyZWU7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKHcgPT4gdy5yZW5kZXJlZCgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy50cmVlO1xuXG4gICAgICB9XG5cbiAgICAgfVxuXG4gICAgYDtcblxuIl19